/**
 * this - это то, что окружает функцию и в каких условиях она вызывается.
 *
 * если ты без дома, то ты функционируешь в прдлах всего мира. но еесли ты в определенном учрежднии, где он сможет жить и чем-то заниматься, то он получит свой контект вызова. у него есть свое место для функционирования.
 *
 * функция может вызыыаться четырьмя способами. и в каждом из них конткст вызова будет отличаться.
 *
 * 1)
 * function show(){console.log(this)}
 * если мы вызываем функцию как выше и она будет просто ссылаться на контекст, то ее конткст будет ссылаться на window.
 * если есть строгий режим 'use strict, то this будет андефайнд.
 *
 * use strict
 * function show(a,b){
 *      console.log(this)  //undef
 *      functions sum(){
 *              console.log(this)
 *              return this.a + this.b; //тут будет ошибка. чтобы избежать, нужно удалить this. функция сперва смотрит в себя, потом наружу. найдет снаружи.
 *              }
 *      console.log(sum());
 * }
 * show(4,5)
 * 
 * 2)
 * const obj = {
 * a:20,
 * b:15,
 * sum: function(){
 *      console.log(this)
 *  }
 * }
 * 
 * obj.sum() //выведет объект.
 * если мы используем метод внутри объекта, то конткст вызова будет всегда объкт. 
 * если внутри нашего метода, будет функция, а внутри будет this, то он выведет undefined. т.к. это простой вызов функции. 
 * 
 * 3) функции конструкторы.
 * function User(name, id) {
	this.name = name;
	this.id = id;
	this.human = true;

	//и вот когда и использовали такой синтаксис наша функция стала конструктором. с ее помощью мы теперь можем создавать новых пользователей.
	this.hello = function () {
		console.log(`Hello ${this.name}`);
	};
}
 * const ivan = new User('ivan', 1);
 * 
 * когде будет вызвана, она создаст новый объект. 
 *  !!!!!! this в контрукторах и классах это новыыый экземпляр объекта. !!!!!!!!!!
 * 
 * 4) ручное присвоение this любой функции. 
 * funcion sayName(){
 *      console.log(this)
 *      console.log(this.name)
 * }
 * const user = {
 *      name: 'john'
 * }
 * как запускать функцию так, чтобы контекст у нее был не undefined, а именно user'a. 
 * для этого существует два метода call и apply
 * 
 * sayName.call(user)
 * sayName.apply(user)
 * разница в синтаксисе если в основную функцию нужно передать доп парамтр. 
 * просто строку, или же массив со строкой.
 * 
 * 5) bind создает новую функцию с определенным контекстом! 
 * 
 * function count(num){ this*num}
 * const double = count.bind(2)  - такое может часто встречаться в реакте. 
 * 
 * 
 * 
 * 
 * когда в обработке событий используешм классическую функцию в качестве колбэека, наш контекст вызова будет сам элемент на котором произошло событие. = event.target.
 * 
 * разберем как работают стрелочные функции с контекстом вызова. 
 * стрелочные функции не имеют своего контекста вызова. они всегда будут брать его у своего родителя.
 * 
 * const obj = {
 * 	num:5,
 * 	sayNumber: function(){
 * 			const say = () =>{
 * 						console.log(this)
 * 					}
 * 			say()
 * 		}
 * };
 * obj.sayNumber();// this будет равняться объекту. 
 * 
 * 
 * const double = (a)=>{ 
 * 		return a*2
 * }
 * 
 * const double = (a)=> a*2
 * 
 * поскольку
 */
