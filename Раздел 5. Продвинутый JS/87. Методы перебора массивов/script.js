'use strict';
//очень полезная тема особенно после того, как научились работать с сервером, получать какие-то данные  и теперь необходимо их как-то обработать. например - отфильтровать, бо полностью поменять каждый элемент массив и многое другое.

//форИч - не возвращает нам новый массив, он просто берет массив и просто перебирает его.
//Все остальные методы возвращают нам новый массив.
const names = ['Ivan', 'Ann', 'Ksenia', 'Voldemart'];
//filter - филььрует элементы внутри массивов. нужно какое-то правило.
//Получить все имна которые меньш 5 символов
const shNames = names.filter(function (name) {
	//будем возвращать те элеементы, которые будут совпадать по нашему кретерию.
	return name.length < 5;
});
console.log(shNames);

//map - тарнсформирует каждый элемент массива
const answers = ['AnsaWW', 'AnnA', 'Hello'];

const res = answers.map((item) => {
	return item.toLocaleLowerCase();
});
console.log(res);
//так же нам не необходимо кадый раз создавать новую переменную, мы можем перезаписать в текущую переменную новый результат обработки данных. пример ниже.
let answers2 = ['AnsaWW', 'AnnA', 'Hello'];
answers2 = answers2.map((item) => {
	return item.toLocaleLowerCase();
});
console.log(answers2);
//однако, исходя из программирования и такого понятия как иммутабельность этого делать не стоит. и лучше все таки создавать новую переменную которая будет содержать новые результаты а исходные данные будут на своем месте.
//мап будем часто использовать в реакте для того, чтобы как-то трансформировать данные приходящие с сервера.

//every/some - some - еслии какой-то элемент будет подходить под условие, он нам вернет тру, а если неет, то фолс; every -

const some = [4, 'qwe', 'asdfasdf'];

console.log(some.some((item) => typeof item === 'number')); //еесть лии хотя бы одно чисто - тру
console.log(some.every((item) => typeof item === 'number')); //еесть лии все элементы являются числом - фолс.
//если статистическая программа, то проверяете если зп у всех людй больше чем 100 бачей, то возвращаем тру - понадобится эври.
// чтобы проверить зп у какого-то человека больше 10к то используем сом.
//можно и в ручную перебрать. но это сложно и можно бз него.

//reduce - самый сложный. служит чтобы схлопывать или собирать массив в одно единое целое. особено числовые данные.
const arr = [4, 5, 1, 3, 2, 6];
//наша задачка это быстро взять и получить сумму всех элементов. можно перебрать чрез форИч, складывая в глобальную переменную.
//но у нас есть этот метод, чтобы собрать массив воедино. возвращает новый уже сформированный результат. это метод перебора.
const resArr = arr.reduce((sum, current) => {
	sum + current;
});
//когда мы его запускаем у него есть два аргумента, которые подставляются автоматически. первый - сумма всех элементов, и изначально он равен 0(нуль), карент - каждый элемент, который приходит с массива. сначала получим 0+4 = 4. следующий аргумент каррент - 5, а сум 4 итого 10.
//она проходит по всем элементам и складывает их.
//вот таким способом схлопываем массив.

//массив со строками. его тоже можно собрать воедино.
const arr2 = ['apple', 'pear', 'plum']; //одна большая строка через запятую.
//v1
const resArr2 = arr2.reduce((sum, current) => sum + ', ' + current);
//v2
const resArr21 = arr2.reduce((sum, current) => `${sum}, ${current}`);

//можем еще после колбека поставвить начальное значение.

//конкретный кейс.
const obj = {
	ivan: 'persone',
	ann: 'persone',
	dog: 'animal',
	cat: 'animal',
};

//вытащить имена.
//entries - метод массивов.

const newArr = Object.entries(obj);
console.log(newArr);
//прием chaining. то есть в цепочку.
const newArr2 = Object.entries(obj)
	.filter(
		(item) =>
			/**вернется только массив 2й элемент равен персон  */
			item[1] === 'persone'
	)
	.map((item) => {
		//трансформируем полученный массив после фильтрации. хочу получить только имена.
		item[0];
	});

//Если после => мы не ставим открытие скобок, то return подставляется автоматически.
(item) => {
	//трансформируем полученный массив после фильтрации. хочу получить только имена.
	item[0];
};

//все эти методы позволяют получить новый массив. отсюда мысоблюдаем иммутабельность а так же можно использовать их по цепочке.

for (let i = 2; i <= 16; i++) {
	if (i % 2 === 0) {
		continue;
	} else {
		console.log(i);
	}
}

let i = 2;
while (i <= 16) {
	// i++;
	// console.log(i);
	if (i % 2 === 0) {
		i++;
		continue;
	} else {
		console.log(i);
		i++;
	}
	// i++;
}

let i2 = 2;
while (i2 <= 16) {
	console.log(i2);
	i2++;
}

const arrr = [3, 5, 8, 16, 20, 23, 50];
const result = [];

for (let i = 0; i < arrr.length; i++) {
	result.push(arrr[i]-1);
	// console.log(result);
}
console.log(result);
console.log(arrr);