'use strict';
/**
 * Обещания.
 *
 * она позволяет нам работать с различным ассинхронным кодом:
 * - таймауты
 * - при запросах на сервер
 *
 *
 * можно сделать поледовотеельность действий. сделали что-то, то мы выполним действия и так по цепочке.
 * если выполнится что-то, то мы обещает что выполнится действие.
 *
 * для выполнение цепочки можно написать много функций обратного вызова(колбэки), но такое называется колбек-хелл.
 * чтобы не попадать в это нам нужно использовать промисы.
 */

//const test = new Promise(); // обещание создано, и во внутрь нам нужно поместить какую-то колбек функцию. обычно эта колбек функция принимает два аргумента - ресолв, реджект.

const req = new Promise(function (resolve, reject) {
	//resolve - что-то выполнилось правильно.
	//не выполнилось и что-то пошло не так.
	setTimeout(() => {
		console.log('Подготовка данных...');
		const product = {
			name: 'TV',
			price: 2000,
		};
		resolve(product);
		//пердаем наш продукт в функцию, которую мы описали в then ниже.
	}, 2000);
});
req.then((product) => {
	//тen мы их получили и продолжили работу.
	console.log('Данные получены.');
	// setTimeout(() => {
	// 	product.status = 'order';
	// 	console.log(product);
	// }, 2000);
	//ддопустим нужно сделать еще пару действий. для этого сделаем еще промис.
	// const req2 =
	return new Promise(function (resolve, reject) {
		setTimeout(() => {
			product.status = 'order';
			resolve(product);
		}, 2000);
	});
})
	.then((data) => {
		console.log(data);
		data.modiify = true;
		return data; //мы вернули и передали для работы далее.
	})
	.then((data) => {
		console.log(data);
	});
console.log('text');

//Мы создаем обещание которое кладем в переменную req. Обещание может завершиться как положительно так и отрицательно. но в данный момент мы не знаем как оно завершится до того как мы получим реезультат, т.е. у нас есть какой-то промежуток времени до того как мы получим результат. по факту мы не знаем как ответит у нас сервер.
//внутри проминуса с колбеке у нас есть два аргумента - ресолв и реджект. по факту это аргументы вместо которых у нас будет подставляться функции. если все океф - то ресолв, а еси с ошибкой то реджект. для того, чтобы обрабатывать положительный результат у нас сть такой метод как .then(); он внутри себя принимает тот аргумент с функцией, который и называется ресолв.

//мы можеем возвращать промисы по цепочке. дл яэтого вместо создание новой переменной ы просто вернем новый

//из таких колбеков мы можем возвращать не только промисы. можно вернуть что-то и работать с ним далее. по примеру с data.
//мы добиваемся последовотельности кода, в независимости от того какой там код - синхронный или ассинхронный.

//lkя того, чтобы обработать ошибку нам нужно добавить вызов функции reject в промисе. а после всех цепочек then поставить catch. синтаксис такой же, т.е. внутрь нам нужно добавить стрелочную функцию.

//у нас есть еще блок кода finally - это блок кода который выполнится абсолютно всегда.

//есть еще два метода - all , race

const test = (time) => {
	return new Promise((resolve) => {
		setTimeout(() => {
			resolve();
		}, time);
	});
};

test(1000).then(() => {
	console.log('1000 ms');
});
test(2000).then(() => {
	console.log('2000 ms');
});
//all - принимает в себя массиив с промисами.
Promise.all([test(1000), test(2000)]).then(() => {
	//для того чтобы убдиться, что все наши промисы выполнились.
	//несколько запросов на разные сервера чтобы получить определенные изображеения.
	console.log('All');
});

//race выполнится тогда, когда первый промис выполнится .
Promise.race([test(1000), test(2000)]).then(() => {
	console.log('race');
});
