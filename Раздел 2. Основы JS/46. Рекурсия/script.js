//Рекурсия - это вызов функции самой себя.

//функция возведения в степень.
// pow(2, 2); //4
// pow(2, 3); //8
//pow(2, 4); //16

//НАпишем такую функцию по простому.
function pow(x, n) {
	let result = 1;
	for (let i = 0; i < n; i++) {
		//
		result *= x;
		// result = x * result;
	}
	console.log(result);
	return result;
}

// pow(2, 4);
function pow2(x, n) {
	console.log('n', n);
	if (n === 1) {
		return x;
	} else {
		// console.log(x * pow2(x, n - 1));
		return x * pow2(x, n - 1); //рекурсия
		//когда приходит 2, 3. 2 * (2,2). делает тоже самое что и цикл.
	}
}
let res = pow2(2, 4);
console.log(res);
//База рекурсии.
//случай, когда приводит сразу к завершению функции.
//когда передается n = 1, то это база. этот случай приводит к тому, что выводит сразу это значение. даже когда передаем большое значение, то рекурсия когда-то придет к своей базе.  (это 1)

//Шаг рекурси - это запуск вложенной функции, но уже с другим значением. в наем случае n-1
//глубина реккурсии - колв-о вложенных вызовов вместе с самым первым. это n.

//Максимальная шлубина - это частный случае глубины рекурсии, т.е. насколько далеко может нырнуть рекурсия сама в себя. зависит от сложности действия и возможности железа. в районе 10к.

//чтоже тогда использовать?
//1. итеративный подход обычно эффективнее. (цикл). это связанно с внутренним устройством языка и такмими вещами как контекст и стек вызова.

let students = {
	js: [
		{ name: 'John', progress: 100 },
		{ name: 'Ivan', progress: 60 },
	],
	html: {
		basic: [
			{ name: 'Peter', progress: 20 },
			{ name: 'Ann', progress: 18 },
		],
		pro: [{ name: 'Sam', progress: 10 }],
	},
};
